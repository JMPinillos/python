1
00:00:00,000 --> 00:00:02,685
多層ニューラルネットワーク用の

2
00:00:02,685 --> 00:00:04,695
私の解がこれです

3
00:00:04,695 --> 00:00:08,505
MNISTデータセットからの
手書き数字を分類するためのものです

4
00:00:08,505 --> 00:00:11,850
前のようにここでも活性化関数を
定義しています

5
00:00:11,849 --> 00:00:15,464
ここでもシグモイド関数があり
imagesを平坦化しています

6
00:00:15,464 --> 00:00:19,859
テンソルの形を変更する方法を
思い出してください

7
00:00:19,859 --> 00:00:21,285
ここでは.viewを使用しています

8
00:00:21,285 --> 00:00:23,579
バッチサイズを得ています

9
00:00:23,579 --> 00:00:25,184
images.shapeです

10
00:00:25,184 --> 00:00:27,719
１つ目の要素の０がここにあります

11
00:00:27,719 --> 00:00:32,924
imagesのテンソルのバッチ数を示します

12
00:00:32,924 --> 00:00:35,459
バッチ数を同じにしておきたいですが

13
00:00:35,460 --> 00:00:38,384
残りの次元を平坦化したいです

14
00:00:38,384 --> 00:00:41,149
-１を入力するだけで できます

15
00:00:41,149 --> 00:00:44,600
784とここでは入力できますが

16
00:00:44,600 --> 00:00:48,410
ショートカットで-１を入力するだけで
これを行えます

17
00:00:48,409 --> 00:00:54,979
これが行うのは基本的にここでバッチ
サイズとして64を使用することです

18
00:00:54,979 --> 00:00:58,099
-１を入力するとこれを確認してから
適切なサイズを選択して

19
00:00:58,100 --> 00:01:02,270
エレメントの総数を得られるようにします

20
00:01:02,270 --> 00:01:07,219
２次元を784に
するために必要な作業を行うのです

21
00:01:07,219 --> 00:01:10,219
一致の形の変更後の要素数は

22
00:01:10,219 --> 00:01:13,674
形の変更前の要素数に
一致するようになります

23
00:01:13,674 --> 00:01:17,134
使用される２次元がどのようなものか
知らなくても

24
00:01:17,135 --> 00:01:21,245
テンソルをフラット化する簡単な方法は
この通りです

25
00:01:21,245 --> 00:01:25,025
次に 重みとバイアスの
パラメーターを作成してみます

26
00:01:25,025 --> 00:01:33,020
784ユニットの入力と256の隠れ
ユニットを求めていることは知っています

27
00:01:33,019 --> 00:01:37,069
したがって１つ目の重みのマトリックスは
(784, 256)です

28
00:01:37,069 --> 00:01:41,359
次に隠れユニットのそれぞれに
バイアス項が必要です

29
00:01:41,359 --> 00:01:45,120
b１では256のバイアス項があります

30
00:01:45,120 --> 00:01:48,829
隠れ層から出力層への２つ目の重みは

31
00:01:48,829 --> 00:01:53,569
256の入力から10の出力にしたいです

32
00:01:53,569 --> 00:01:55,684
それからバイアスを10要素とします

33
00:01:55,685 --> 00:02:02,629
１つ目の重みのパラメータである
１つ目の重みのセットにより入力の

34
00:02:02,629 --> 00:02:04,189
マトリックスの掛け算を行う前に

35
00:02:04,189 --> 00:02:07,640
バイアス項で追加を行い

36
00:02:07,640 --> 00:02:10,939
活性化関数を通じて受け渡しを行い
隠れ層の出力が得られるようにします

37
00:02:10,939 --> 00:02:15,395
これを出力層への入力として使用できます

38
00:02:15,395 --> 00:02:19,969
重みの２つ目のセットとバイアス項の
２つ目のセットのマトリックス乗算です

39
00:02:19,969 --> 00:02:23,134
これによりネットワークの出力が
得られます

40
00:02:23,134 --> 00:02:26,209
このネットワークの出力を確認すると

41
00:02:26,210 --> 00:02:29,450
この64が得られることが分かります

42
00:02:29,449 --> 00:02:32,629
この形をまず出力して
正しく行われていることを確認します

43
00:02:32,629 --> 00:02:40,164
一種類の入力例それぞれに対して
64行そして10の値です

44
00:02:40,164 --> 00:02:42,530
この数字のように 画像がクラスに
属していることが

45
00:02:42,530 --> 00:02:46,414
読み取れる値に 基本的にはなります

46
00:02:46,414 --> 00:02:50,530
したがって 出力テンソルを点検して
ここで何が行われているかを確認します

47
00:02:50,530 --> 00:02:53,640
値は至る所にあります

48
00:02:53,639 --> 00:02:57,144
６や-11などが得られます

49
00:02:57,145 --> 00:03:00,469
しかし本当に必要なのは
いくつかの画像が与えられたときに

50
00:03:00,469 --> 00:03:04,159
ネットワークにより異なるクラスの
確率が得られるようにすることです

51
00:03:04,159 --> 00:03:09,500
ネットワークに画像を受け渡し
それにより出力を確率の配布にしたいのです

52
00:03:09,500 --> 00:03:12,050
画像に属する可能性が最も高い
クラスや数字が得られます

53
00:03:12,050 --> 00:03:16,564
６の画像の場合

54
00:03:16,564 --> 00:03:19,254
６番目のクラスにある可能性が最も高い

55
00:03:19,254 --> 00:03:21,829
確率の分布が必要です

56
00:03:21,830 --> 00:03:24,995
したがってこれは数字６だと伝えられます

57
00:03:24,995 --> 00:03:27,115
このようなものを確認しましょう

58
00:03:27,115 --> 00:03:29,375
クラスの確率のようなものです

59
00:03:29,375 --> 00:03:31,520
受け渡していた画像により

60
00:03:31,520 --> 00:03:33,725
異なるクラスの確率が得られます

61
00:03:33,724 --> 00:03:37,814
これらの異なるクラスの

62
00:03:37,814 --> 00:03:39,604
確率がおおよそ同じであることが
分かります

63
00:03:39,604 --> 00:03:41,449
つまりこれは一様分布なのです

64
00:03:41,449 --> 00:03:43,984
これはトレーニングされていない
ネットワークを示しますので

65
00:03:43,985 --> 00:03:46,310
一様確率分布です

66
00:03:46,310 --> 00:03:49,164
データをまだ確認していないため 画像を

67
00:03:49,164 --> 00:03:51,049
何も学習していません

68
00:03:51,050 --> 00:03:53,495
画像を提供しても

69
00:03:53,495 --> 00:03:57,004
それが何であるか分からず
各クラスに同一の確率を算出するだけです

70
00:03:57,004 --> 00:04:00,949
受け渡す画像がどのようなもの
であってもです

71
00:04:00,949 --> 00:04:03,369
望んでいるのはネットワークの出力を

72
00:04:03,370 --> 00:04:07,355
画像がクラスの１つに属している確率を

73
00:04:07,354 --> 00:04:10,669
得られる確率分布です

74
00:04:10,669 --> 00:04:14,959
これに対しては
ソフトマックス関数を使います

75
00:04:14,960 --> 00:04:17,944
指数関数のようなものです

76
00:04:17,944 --> 00:04:20,540
10の値を受け渡します

77
00:04:20,540 --> 00:04:22,670
これらの値のそれぞれに対して

78
00:04:22,670 --> 00:04:24,455
その値の指数関数をすべての値の
指数関数の和で割ることにより

79
00:04:24,454 --> 00:04:26,764
計算を行います

80
00:04:26,764 --> 00:04:29,555
０と１の間の各入力値Xを

81
00:04:29,555 --> 00:04:33,139
押しつぶすような感じです

82
00:04:33,139 --> 00:04:36,680
それからすべての値を正規化し

83
00:04:36,680 --> 00:04:39,470
各確率の和が１になるようにします

84
00:04:39,470 --> 00:04:42,870
全体の和が１になります

85
00:04:42,870 --> 00:04:44,939
これにより適切な確率分布が得られます

86
00:04:44,939 --> 00:04:47,524
ここでやりたいことはソフトマックスと

87
00:04:47,524 --> 00:04:50,224
呼ばれる関数で この計算を行います

88
00:04:50,225 --> 00:04:54,310
これから このシンプルな
ニューラルネットワークから出力を得ます

89
00:04:54,310 --> 00:04:57,800
(64, 10)になります

90
00:04:57,800 --> 00:05:02,704
機能不全のソフトマックスを通じて受け渡されます

91
00:05:02,704 --> 00:05:06,694
受け渡した異なる各例の確率分布が

92
00:05:06,694 --> 00:05:11,659
計算されるようにしてください

93
00:05:11,660 --> 00:05:13,130
うまくいきますように

