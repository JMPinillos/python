1

00:00:00,000  -->  00:00:03,765
PCA는 일반적으로 고차원 데이터에 사용됩니다.

2

00:00:03,765  -->  00:00:06,845
고차원 데이터의 한 유형은 이미지입니다.

3

00:00:06,844  -->  00:00:11,814
이 예에서는 손으로 쓴 숫자를 사용하는 매우 흔한 경우를 살펴보겠습니다.

4

00:00:11,814  -->  00:00:17,434
이미지 데이터의 고전적인 예는 1990년대 후반에

5

00:00:17,434  -->  00:00:23,839
Microsoft, Google 및 NYU의 연구원들이 공개한 MNIST 데이터세트입니다.

6

00:00:23,839  -->  00:00:28,524
통합 문서의 아래 정보에서 이 데이터세트에 대한 자세한 내용을 링크했습니다.

7

00:00:28,524  -->  00:00:31,174
시작하려면 필요한 라이브러리를 가져온 후

8

00:00:31,175  -->  00:00:34,130
데이터세트를 읽는 것이 중요합니다.

9

00:00:34,130  -->  00:00:39,130
이 경우 훈련 데이터세트에 있는 42,000개의 이미지를 읽습니다.

10

00:00:39,130  -->  00:00:40,880
테스트 데이터세트에는

11

00:00:40,880  -->  00:00:44,520
아직 작업하지 않은 28,000개의 추가 이미지가 포함되어 있으므로

12

00:00:44,520  -->  00:00:47,085
데이터세트의 헤더를 볼 수 있습니다.

13

00:00:47,085  -->  00:00:49,820
설명도 볼 수 있습니다.

14

00:00:49,820  -->  00:00:56,280
이 경우 손으로 쓴 숫자가 있는 레이블 열이 있음을 알 수 있습니다.

15

00:00:56,280  -->  00:01:00,760
이것은 1의 이미지입니다. 이것은 0의 이미지,

16

00:01:00,759  -->  00:01:03,184
1의 이미지, 4의 이미지입니다.

17

00:01:03,185  -->  00:01:05,504
그런 다음 측면을 살펴보면

18

00:01:05,504  -->  00:01:09,589
이미지의 특정 픽셀에 얼마나 많은 잉크가 있었는지

19

00:01:09,590  -->  00:01:14,600
나타내는 0에서 255 사이의 값이 있고 설명을 보면 이 마지막 값에

20

00:01:14,599  -->  00:01:17,689
누락된 값이 있는 것처럼 보입니다.

21

00:01:17,689  -->  00:01:20,504
그래서 지금은 0으로 채우겠습니다.

22

00:01:20,504  -->  00:01:23,524
픽셀의 일부 모서리 부분에 있는 것 같습니다.

23

00:01:23,525  -->  00:01:25,190
데이터에 대해 알고 있는 정보를 바탕으로

24

00:01:25,189  -->  00:01:29,079
레이블을 분리하고 이미지를 자체 행렬에 넣습니다.

25

00:01:29,079  -->  00:01:31,459
저는 여기 레이블을 떼었습니다.

26

00:01:31,459  -->  00:01:35,524
이제 이 작은 도우미 기능으로 이미지가 어떻게 보이는지 살펴보겠습니다.

27

00:01:35,525  -->  00:01:39,885
이 도우미 기능은 이 동영상 아래의 노트북 핀에서 구할 수 있습니다.

28

00:01:39,885  -->  00:01:42,170
100에서 통과하면

29

00:01:42,170  -->  00:01:44,644
처음 100개의 이미지를 보여주실 수 있나요?

30

00:01:44,644  -->  00:01:46,219
이것을 보면

31

00:01:46,219  -->  00:01:49,344
어떤 값인지 정말 쉽게 알 수 있는 이미지들이 있습니다.

32

00:01:49,344  -->  00:01:50,885
이것은 1, 0,

33

00:01:50,885  -->  00:01:54,505
분명히 8에서 9처럼 보입니다.

34

00:01:54,504  -->  00:01:57,289
하지만 이와 같이 보이는 다른 이미지가 있습니다.

35

00:01:57,290  -->  00:02:01,790
이것은 어떤 값이 될 수 있는데 여기 있는 것은 어떻습니까? 이 값은 무엇일까요?

36

00:02:01,790  -->  00:02:04,640
모든 유형의 숫자의 처음 50개 이미지를 볼 수 있게 하는

37

00:02:04,640  -->  00:02:07,745
또 다른 도우미 기능이 있습니다.

38

00:02:07,745  -->  00:02:10,250
다시 말하지만, 아래 통합 문서에서 이를 확인할 수 있습니다.

39

00:02:10,250  -->  00:02:12,379
따라서 이 함수를 사용하여

40

00:02:12,379  -->  00:02:15,590
보고자 하는 숫자를 전달할 수 있고

41

00:02:15,590  -->  00:02:19,430
해당 숫자의 처음 50개 이미지를 볼 수 있습니다.

42

00:02:19,430  -->  00:02:22,240
여기에서 처음 50개를 볼 수 있습니다.

43

00:02:22,240  -->  00:02:26,775
그것이 우리가 이전에 보았던 이 숫자가 실제로 있는 것입니다. 여기를 보세요

44

00:02:26,775  -->  00:02:28,969
이들 중 일부는 머신러닝 알고리즘을 사용하여

45

00:02:28,969  -->  00:02:31,074
예측하기가 매우 쉬워 보입니다.

46

00:02:31,074  -->  00:02:34,219
그러나 그들 중 다른 것들은 확실히 더 어렵습니다.

47

00:02:34,219  -->  00:02:36,634
이것들을 예측하는 데 첫 번째 패스를 하기 위해서입니다.

48

00:02:36,634  -->  00:02:38,989
이것들을 랜덤 포레스트 알고리즘에 전달할 수 있도록

49

00:02:38,990  -->  00:02:41,920
제가 작성한 또 다른 도우미 함수가 있습니다.

50

00:02:41,919  -->  00:02:44,569
random_forest_classifier 함수를 사용하면

51

00:02:44,569  -->  00:02:46,090
그것은 아래 노트북에 있습니다.

52

00:02:46,090  -->  00:02:50,189
데이터세트가 학습 및 테스트 세트로 분할되는 것을 볼 수 있습니다.

53

00:02:50,189  -->  00:02:53,859
RandomForestClassifier를 인스턴스화하여

54

00:02:53,860  -->  00:02:57,735
훈련 데이터세트에 맞춘 후 테스트 데이터세트에서 예측합니다.

55

00:02:57,735  -->  00:03:01,295
그런 다음 다음 결과에 대한 chaos_matrix를 작성합니다.

56

00:03:01,294  -->  00:03:03,219
얼마나 잘 되는지 살펴보겠습니다.

57

00:03:03,219  -->  00:03:06,080
그래서 대각선을 따라 있는 모든 것은

58

00:03:06,080  -->  00:03:09,705
기본적으로 우리가 실제로 참인 동일한 값을 예측한 것이고,

59

00:03:09,705  -->  00:03:12,215
비대각선에 있는 이러한 값은

60

00:03:12,215  -->  00:03:15,205
참이 아닌 값을 예측한 것입니다.

61

00:03:15,205  -->  00:03:18,210
거의 94%의 시간 동안

62

00:03:18,210  -->  00:03:22,795
해당 이미지의 모든 픽셀을 사용하여 값을 올바르게 예측할 수 있음을 알 수 있습니다.

63

00:03:22,794  -->  00:03:26,269
여기에서 진한 파란색은 비대각선 양쪽에 잘못

64

00:03:26,270  -->  00:03:30,425
레이블이 지정된 이미지가 거의 없음을 나타냅니다.

65

00:03:30,425  -->  00:03:33,740
대각선을 따라 있는 이러한 요소는 올바르게 예측되는 값과

66

00:03:33,740  -->  00:03:37,830
관련된 매우 높은 숫자가 있음을 나타냅니다.

67

00:03:37,830  -->  00:03:41,650
따라서 우리는 모든 픽셀을 사용하여 정말 잘 예측할 수 있다는 것을

68

00:03:41,650  -->  00:03:45,670
알 수 있지만 주성분 분석을 사용하여 더 적은 수의 기능을 생성하고

69

00:03:45,669  -->  00:03:50,464
여전히 동일한 수준의 정확도로 예측할 수 있는지 궁금합니다.

70

00:03:50,465  -->  00:03:55,375
이를 위해 데이터세트로 PCA를 수행하는 추가 도우미 기능이 있습니다.

71

00:03:55,375  -->  00:04:01,150
따라서 do_pca 함수는 특정 수의 성분과 데이터세트를 가져와

72

00:04:01,150  -->  00:04:03,580
PCA에 맞춘 후 감소된 수의

73

00:04:03,580  -->  00:04:06,680
기능이 포함된 X 행렬과 적합한

74

00:04:06,680  -->  00:04:09,230
PCA 모델을 반환합니다.

75

00:04:09,229  -->  00:04:13,674
우선 두 가지 추가 기능만 만들어 보겠습니다.

76

00:04:13,675  -->  00:04:18,280
그래서 두 가지 기능과 모든 픽셀인 X 행렬을 전달한 후

77

00:04:18,279  -->  00:04:23,904
PCA 객체를 반환합니다.

78

00:04:23,904  -->  00:04:30,284
그래서 이것을 pca라고 부르면 RPCA와 관련된 X 행렬이 나옵니다.

79

00:04:30,285  -->  00:04:33,655
따라서 do_pca 함수를 사용하면

80

00:04:33,654  -->  00:04:36,549
여러 성분과 입력 데이터,

81

00:04:36,550  -->  00:04:39,375
데이터세트의 기능을 취한 후

82

00:04:39,375  -->  00:04:43,550
PCA 객체 자체와 변환된 기능의 DataFrame을

83

00:04:43,550  -->  00:04:48,100
반환한다는 것을 알 수 있습니다.

84

00:04:48,100  -->  00:04:53,490
따라서 이것을 사용하여 pca 및

85

00:04:53,490  -->  00:04:59,280
X_pca 성분을 돌려주고 PCA를 수행할 수 있습니다.

86

00:04:59,279  -->  00:05:04,839
두 개의 성분을 다시 원하고 데이터세트의 X 행렬에서 수행한다고 가정해 보겠습니다.

87

00:05:04,839  -->  00:05:07,304
따라서 우리가 반환하는 DataFrame은

88

00:05:07,305  -->  00:05:12,230
X_pca 성분을 보면 동일한 행 수입니다.

89

00:05:12,230  -->  00:05:14,390
그러나 두 개의 열만 있는 것을 볼 수 있습니다.

90

00:05:14,389  -->  00:05:19,024
이는 행 수는 같지만 각 이미지의 DataFrame에서

91

00:05:19,024  -->  00:05:24,620
784픽셀인 원본과 많이 다릅니다.

92

00:05:24,620  -->  00:05:31,670
여기서 우리가 했던 것과 동일한 머신러닝 알고리즘인 랜덤 포레스트 분류자를

93

00:05:31,670  -->  00:05:33,160
사용하여 다시 시도해 볼 것입니다.

94

00:05:33,160  -->  00:05:37,895
두 가지 기능만으로 숫자를 얼마나 잘 예측할 수 있는지 확인할 수 있습니다.

95

00:05:37,894  -->  00:05:44,189
해보겠습니다. 따라서 우리가 사용할 X는 X_pca이고 y를 예측합니다.

96

00:05:44,189  -->  00:05:46,644
자릿수 중 35%만 올바르게 분류하고

97

00:05:46,644  -->  00:05:51,279
여기 아래에서 볼 수 있는 행렬을 통해 얻은

98

00:05:51,279  -->  00:05:58,309
이전 예보다 성능이 훨씬 나쁘다는 것을 알 수 있습니다.

99

00:05:58,310  -->  00:06:01,240
정말로, 우리가 아주 잘 예측하고 있는 유일한 것은

100

00:06:01,240  -->  00:06:05,685
1이고 다른 모든 것은 꽤 나쁩니다. 7은 괜찮습니다.

101

00:06:05,685  -->  00:06:08,225
그러나 우리는 이것으로부터 많은 기능을 얻지 못하고 있습니다.

102

00:06:08,225  -->  00:06:13,680
성분이 손으로 쓴 숫자를 어떻게 구분하는지 더 잘 확인하기 위해

103

00:06:13,680  -->  00:06:16,439
plot_components 함수를 사용하겠습니다.

104

00:06:16,439  -->  00:06:20,725
따라서 이상적인 경우는 우리가 모든 값을 플롯했지만

105

00:06:20,725  -->  00:06:23,275
우리의 플롯이 상당히 압도적일 것입니다.

106

00:06:23,274  -->  00:06:30,019
그래서 제가 할 것은 첫 번째 100을 취하는 것입니다. 여기서 보시다시피

107

00:06:30,019  -->  00:06:32,889
0과 7을 분리하는 작업이

108

00:06:32,889  -->  00:06:34,949
꽤 잘 이뤄집니다.

109

00:06:34,949  -->  00:06:37,314
하지만 다른 모든 것은 함께 뭉쳐져 있는데,

110

00:06:37,314  -->  00:06:42,199
이것은 우리가 여기 이 혼동 행렬에서 본 것을 정확히 나타냅니다.
