1

00:00:00,000  -->  00:00:01,544
마지막 동영상에서는

2

00:00:01,544  -->  00:00:04,724
주요 구성 요소의 주요 측면을 두 가지 살펴보았죠.

3

00:00:04,724  -->  00:00:08,765
첫 번째는 각 구성 요소가 포착한 가변성의 양이었습니다.

4

00:00:08,765  -->  00:00:10,794
scree 플롯으로 볼 수 있었고요.

5

00:00:10,794  -->  00:00:14,144
두 번째는 실제 구성 요소 자체였습니다.

6

00:00:14,144  -->  00:00:18,439
이 notebook에서 여러분은 이에 대해 스스로 좀 더 탐구할 기회를 얻게 됩니다.

7

00:00:18,440  -->  00:00:21,665
필요한 라이브러리와 우리의 데이터를 읽어 봅시다.

8

00:00:21,664  -->  00:00:23,799
상위 30개 이미지입니다.

9

00:00:23,800  -->  00:00:27,210
X 행렬에서 PCA를 수행하는데,

10

00:00:27,210  -->  00:00:31,144
이때는 우리가 이전 동영상에서 사용했던 do_pca 함수를 사용합니다.

11

00:00:31,144  -->  00:00:34,695
이는 PCA 모델 자체는 물론

12

00:00:34,695  -->  00:00:37,774
축소된 기능 행렬을 반환할 것이라는 점을 기억하세요.

13

00:00:37,774  -->  00:00:41,030
이 경우 10개의 주요 구성 요소를 사용합니다.

14

00:00:41,030  -->  00:00:43,064
이를 X 행렬에 전달하고 싶겠죠.

15

00:00:43,064  -->  00:00:45,474
실질적으로 이미지 그 자체이기 때문입니다.

16

00:00:45,475  -->  00:00:50,725
이제 방금 생성한 모델을 사용해 scree 플롯을 생성해 볼까요.

17

00:00:50,725  -->  00:00:53,240
기억하세요. 각 막대는

18

00:00:53,240  -->  00:00:55,950
각 구성 요소가 포착한 가변성의 양을 나타냅니다.

19

00:00:55,950  -->  00:00:58,165
첫 번째 구성 요소에서는 이만큼을 포착하고

20

00:00:58,164  -->  00:01:00,670
두 번째여서는 이만큼을 포착하는 식으로 이어지죠.

21

00:01:00,670  -->  00:01:03,140
선은 특정 구성 요소 수준에서 포착한

22

00:01:03,140  -->  00:01:06,099
총 가변성의 양을 나타냅니다.

23

00:01:06,099  -->  00:01:08,329
따라서 10개 구성 요소가 끝나면

24

00:01:08,329  -->  00:01:11,209
이 10개의 구성 요소가 포착한 데이터에서

25

00:01:11,209  -->  00:01:14,544
원본 가변성의 약 30%를 갖게 됩니다.

26

00:01:14,545  -->  00:01:19,004
이를 사용해 10.42 아래 딕셔너리를 채울 수 있죠.

27

00:01:19,004  -->  00:01:21,834
이것이 가장 까다로워 보이는군요. 이 부분은 나중에 다시 돌아오죠.

28

00:01:21,834  -->  00:01:26,209
첫 번째 구성 요소는 항상 가장 많은 양의 변동성을 설명합니다.

29

00:01:26,209  -->  00:01:27,854
사실입니다.

30

00:01:27,855  -->  00:01:31,340
주요 구성 요소는 항상

31

00:01:31,340  -->  00:01:35,454
데이터세트에 남아 있는 가장 큰 가변성을 포착하려 하니까요.

32

00:01:35,454  -->  00:01:38,989
그러므로 첫 번째 구성 요소가 항상 가장 많이 포착하고,

33

00:01:38,989  -->  00:01:40,849
두 번째는 두 번째로 많이 포착하고

34

00:01:40,849  -->  00:01:42,079
이런 식으로 이어지는 겁니다.

35

00:01:42,079  -->  00:01:45,500
첫 번째 구성 요소가 설명하는 데이터의 총 가변성에서

36

00:01:45,500  -->  00:01:47,689
뒤에 나오는 구성 요소의 가변성이

37

00:01:47,689  -->  00:01:50,644
앞에 나오는 구성 요소보다 큰 경우는 절대 없습니다.

38

00:01:50,644  -->  00:01:54,879
첫 번째 구성 요소는 6.13%를 설명하는 것 같군요.

39

00:01:54,879  -->  00:01:58,519
저것은 답 c처럼 보이네요.

40

00:01:58,519  -->  00:02:02,299
그러면 모든 구성 요소가 설명하는 가변성의 총합은 100%보다 클 수 있죠.

41

00:02:02,299  -->  00:02:06,170
그러므로 모든 구성 요소로 설명되는 가변성의 합계가

42

00:02:06,170  -->  00:02:10,800
100%를 초과하는 경우는 결코 없을 겁니다.

43

00:02:10,800  -->  00:02:14,719
주요 구성 요소가 설명할 수 있는 최대의 가변성은

44

00:02:14,719  -->  00:02:18,490
그저 데이터가 시작해야 하는 가변성의 총량일 뿐입니다.

45

00:02:18,490  -->  00:02:20,600
그러므로 100%만 가능하죠.

46

00:02:20,599  -->  00:02:23,264
그러므로 이 문장은 거짓입니다.

47

00:02:23,264  -->  00:02:26,089
그러면 이 10.42는

48

00:02:26,090  -->  00:02:29,939
처음 두 구성 요소로 설명되는 가변성의 총량입니다.

49

00:02:29,939  -->  00:02:32,310
6.13과 4.29가 보이는데요.

50

00:02:32,310  -->  00:02:35,094
이 둘을 합치면

51

00:02:35,094  -->  00:02:37,159
10.42라는 값이 나오죠.

52

00:02:37,159  -->  00:02:40,609
괜찮은 결과가 나온 것 같네요.

53

00:02:40,610  -->  00:02:44,225
게다가 방금 찾은 아이디어에 대한 약간의 강화 요소도 획득했고요.

54

00:02:44,224  -->  00:02:46,489
이제 helper_functions의

55

00:02:46,490  -->  00:02:49,344
plot_component 함수를 사용해 각 구성 요소를 살펴보겠습니다.

56

00:02:49,344  -->  00:02:53,219
아래 5개의 질문에 도움이 될 수 있도록 결과를 활용하세요.

57

00:02:53,219  -->  00:02:54,990
여기에는 2개의 인수가 필요하죠.

58

00:02:54,990  -->  00:02:56,435
동영상의 내용을 기억하신다면요.

59

00:02:56,435  -->  00:02:59,064
첫 번째는 실제 모델이고

60

00:02:59,064  -->  00:03:01,930
두 번째는 플롯을 만들려는 구성 요소입니다.

61

00:03:01,930  -->  00:03:03,694
첫 번째 구성 요소를 플롯으로 작성하면

62

00:03:03,694  -->  00:03:06,509
빠져나가고 있다는 걸 볼 수 있죠. 기본적으로 0입니다.

63

00:03:06,509  -->  00:03:11,875
따라서 이 구성 요소는 0을 식별하는 데 도움이 될 것 같군요.

64

00:03:11,875  -->  00:03:15,645
10개의 구성 요소가 있고 0에서 9까지 인덱싱하는 경우

65

00:03:15,645  -->  00:03:18,395
이는 0이 구성 요소임을 뜻합니다.

66

00:03:18,395  -->  00:03:22,290
그렇다면, 어떤 구성 요소가 3을 식별하는 것처럼 보이나요?

67

00:03:22,289  -->  00:03:24,544
자, 다른 것들을 살펴볼까요.

68

00:03:24,544  -->  00:03:27,214
저건 3처럼 보이지 않죠.

69

00:03:27,215  -->  00:03:30,474
제 눈에도 3처럼 보이지 않네요.

70

00:03:30,474  -->  00:03:32,979
아! 여기 있습니다. 네 번째 구성 요소군요.

71

00:03:32,979  -->  00:03:35,000
이것들은 0에서 인덱싱된다는 것을 기억하세요.

72

00:03:35,000  -->  00:03:38,534
하지만 이건 3과 아주 비슷하게 보이는군요.

73

00:03:38,534  -->  00:03:41,125
좋습니다. 그러면 notebook에서 우리는

74

00:03:41,125  -->  00:03:44,724
pCA의 두 가지 주요 부분과

75

00:03:44,724  -->  00:03:47,120
각 구성 요소가 설명하는 분산의 양을 살펴볼 기회가 있었죠.

76

00:03:47,120  -->  00:03:48,974
이는 고유값이라고도 불리죠.

77

00:03:48,974  -->  00:03:50,979
그리고 주요 구성 요소 자체는

78

00:03:50,979  -->  00:03:55,819
원본 이미지의 각 픽셀에 대한 가중치를 제공하고

79

00:03:55,819  -->  00:03:58,189
결과의 끝에서 반환되는 개별 주요 구성 요소에

80

00:03:58,189  -->  00:04:00,914
가중치를 부여합니다. 그렇죠?

81

00:04:00,914  -->  00:04:03,729
이러한 주요 구성 요소를 고유벡터라고 합니다.
