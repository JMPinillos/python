1

00:00:00,000  -->  00:00:01,360
이전 동영상에서는

2

00:00:01,360  -->  00:00:05,425
MNIST 숫자 데이터로 작업하는 예시를 보았습니다.

3

00:00:05,424  -->  00:00:07,915
해당 데이터세트의 링크는 여기에서 찾을 수 있습니다.

4

00:00:07,915  -->  00:00:11,155
먼저 필요한 라이브러리를 로드하는 것이 중요합니다.

5

00:00:11,154  -->  00:00:13,750
그런 다음에는 여러 가지 질문을 살펴볼 것입니다.

6

00:00:13,750  -->  00:00:16,440
가장 먼저 주목해야 할 부분은

7

00:00:16,440  -->  00:00:19,185
이 도우미 함수 라이브러리에서 로드된 항목이 많다는 것입니다.

8

00:00:19,184  -->  00:00:24,210
이는 본질적으로 이전 동영상에서 보았던 다양한 함수와

9

00:00:24,210  -->  00:00:25,740
기타 추가적인 항목입니다.

10

00:00:25,739  -->  00:00:27,629
이 notebook 전반에서 이를 보게 될 겁니다.

11

00:00:27,629  -->  00:00:31,554
가장 먼저 해야 할 일은 pandas를 사용해 데이터세트를 읽는 것입니다.

12

00:00:31,554  -->  00:00:34,335
가장 여기 링크에서 찾아보실 수 있습니다.

13

00:00:34,335  -->  00:00:38,310
헤드, 테일, 설명, 정보 등을 수행하며 데이터를 살펴보고

14

00:00:38,310  -->  00:00:43,145
이에 친숙해질 수 있습니다.

15

00:00:43,145  -->  00:00:46,520
이전 동영상과 마찬가지로 레이블을 보유하고 있으며

16

00:00:46,520  -->  00:00:49,680
나머지 모든 픽셀을 x에 저장하는 y라는 벡터를

17

00:00:49,679  -->  00:00:57,484
생성해 보겠습니다. 또한 이전 동영상에서처럼 0으로 채우려고 합니다. 좋습니다.

18

00:00:57,484  -->  00:00:59,564
자, 된 것 같군요.

19

00:00:59,564  -->  00:01:05,250
이제 도우미 함수에서 숫자 함수로 이미지를 표시하도록 해

20

00:01:05,250  -->  00:01:08,170
1, 2, 3 또는 기타 값을 확인합니다.

21

00:01:08,170  -->  00:01:12,034
이를 실행하면 데이터세트에 있는 모든 2의 항목이 표시됩니다.

22

00:01:12,034  -->  00:01:15,155
이것을 바꾸면, 1을 확인할 수 있죠.

23

00:01:15,155  -->  00:01:19,030
8을 보는 것도 가능하겠고요.

24

00:01:19,030  -->  00:01:21,780
이제 데이터를 살펴볼 기회가 생겼으므로

25

00:01:21,780  -->  00:01:24,320
이 4단계 프로세스를 사용해 모델을 맞추고

26

00:01:24,319  -->  00:01:28,284
숫자를 예측해 모델의 점수를 매겨보겠습니다.

27

00:01:28,284  -->  00:01:31,109
이전 동영상에서 사용했던 모델은

28

00:01:31,109  -->  00:01:33,015
그냥 이 함수를 통하기만 했죠.

29

00:01:33,015  -->  00:01:35,019
이는 랜덤 포레스트 분류자에 적합합니다.

30

00:01:35,019  -->  00:01:38,954
그리드 검색을 시도하거나, 이 모델보다 더 나은 모델을 찾을 수도 있을 겁니다.

31

00:01:38,954  -->  00:01:41,299
데이터세트가 실제로 제대로 되었는지 확인하려면

32

00:01:41,299  -->  00:01:44,084
in-place가 true가 되도록 해야 합니다.

33

00:01:44,084  -->  00:01:49,774
그러면 여기에서 모델의 성능이 어느 정도인지에 대한 예시를 볼 수 있습니다.

34

00:01:49,775  -->  00:01:53,680
다시 말씀드리지만, 이전 동영상에서 본 94% 정도입니다.

35

00:01:53,680  -->  00:01:58,380
이 전체 단원의 목적은 PCA를 살펴보는 것입니다.

36

00:01:58,379  -->  00:02:01,879
이전 동영상에서 보았던 프로세스를 복제하려면

37

00:02:01,879  -->  00:02:05,334
생성된 do-PCA 함수를 사용합니다.

38

00:02:05,334  -->  00:02:08,699
이를 실행하면 두 가지 입력을 받는 것을 볼 수 있는데,

39

00:02:08,699  -->  00:02:11,060
하나는 구성 요소의 수이며, 또 하나는

40

00:02:11,060  -->  00:02:14,224
더 적은 구성 요소로 이동하려는 데이터세트입니다.

41

00:02:14,224  -->  00:02:17,569
그 다음의 출력은 PCA 모델뿐만 아니라

42

00:02:17,569  -->  00:02:21,275
더 적은 수의 기능을 생성해 만들어진 데이터세트이며

43

00:02:21,275  -->  00:02:23,870
기능의 수를 가집니다.

44

00:02:23,870  -->  00:02:27,230
전 이전 동영상에서 두 가지 기능만 사용해 모델을 만들었지만

45

00:02:27,229  -->  00:02:30,090
여러분은 원한다면 더 많은 것을 시도해 보셔도 좋습니다.

46

00:02:30,090  -->  00:02:34,969
x 행렬을 전달하면

47

00:02:34,969  -->  00:02:40,359
PCA 객체와 x 행렬, 이렇게 두 가지를 돌려받습니다.

48

00:02:40,360  -->  00:02:46,280
이제 PCA 객체를 받은 상태이며 기능 세트는 단 2개로 축소되었죠.

49

00:02:46,280  -->  00:02:47,965
다음으로 우리가 할 수 있는 건

50

00:02:47,965  -->  00:02:50,205
랜덤 포레스트 분류자를 맞추는 것입니다.

51

00:02:50,205  -->  00:02:53,850
이는 예전 동영상에서 만들었던 함수 중 하나입니다.

52

00:02:53,849  -->  00:02:56,299
x와 y에서 받으며

53

00:02:56,300  -->  00:02:58,880
혼동 행렬과 정확도를 출력합니다.

54

00:02:58,879  -->  00:03:02,560
그러므로 이 경우에는 성능이 그리 좋지 않음을 알 수 있습니다.

55

00:03:02,560  -->  00:03:06,319
적어도 모든 기능을 사용하는 모델과 비교할 때는 아니죠.

56

00:03:06,319  -->  00:03:09,319
다음 부분에서 우리는 수가 줄어든 기능이

57

00:03:09,319  -->  00:03:13,314
여전히 90퍼센트 이상의 정확도를 보이는지 알아보려 합니다.

58

00:03:13,314  -->  00:03:18,094
네 가지 기능을 수행해 봅시다.

59

00:03:18,094  -->  00:03:22,544
잘 알지 못하는 상태에서 시작한다고 가정합니다.

60

00:03:22,544  -->  00:03:27,234
3이나, 15일 수도 있겠죠.

61

00:03:27,235  -->  00:03:29,425
7을 빼먹었네요. 죄송합니다.

62

00:03:29,425  -->  00:03:31,370
어쨌든, 다음으로 우리가 할 수 있는 일은

63

00:03:31,370  -->  00:03:34,460
동영상에서 보았던 플롯 구성 요소 함수를 사용해

64

00:03:34,460  -->  00:03:36,125
분리가 얼마나 잘 이루어지는지 확인하는 것입니다.

65

00:03:36,125  -->  00:03:38,210
이것은 우리가 전에 보았던 바로 그것입니다.

66

00:03:38,210  -->  00:03:40,224
이제 조금 더 나아가 볼까요.

67

00:03:40,224  -->  00:03:43,745
이 경우 더 나은 분리가 가능한지 확인하려 합니다.

68

00:03:43,745  -->  00:03:47,360
특히 700개 이상의 기능이 아닌, 더 적은 수의 기능에서

69

00:03:47,360  -->  00:03:51,900
90%의 정확도를 얻으려고 하죠.

70

00:03:51,900  -->  00:03:55,110
먼저 3에서 15의 범위로 시작합니다.

71

00:03:55,110  -->  00:03:57,790
필요한 경우 나중에 언제든지 더 높게 잡을 수 있습니다.

72

00:03:57,789  -->  00:04:03,074
이를 do PCA 부분으로 넘기죠.

73

00:04:03,074  -->  00:04:06,454
따라서 여기서부터 do PCA는 실제 함수입니다.

74

00:04:06,455  -->  00:04:09,020
그러므로 좋은 점은 정확도를

75

00:04:09,020  -->  00:04:12,230
출력할 뿐만 아니라, 반환하기도 한다는 거죠.

76

00:04:12,229  -->  00:04:15,364
여기 외부 부분 옆에 있기 때문에 알 수 있는 것입니다.

77

00:04:15,365  -->  00:04:19,240
3에서 15 사이의 각 기능 수에 대해 

78

00:04:19,240  -->  00:04:23,555
우리가 하려는 것은, 우리에게 PCA와 x 행렬을 돌려줄

79

00:04:23,555  -->  00:04:28,925
PCA 알고리즘을 실행하는 것입니다.

80

00:04:28,925  -->  00:04:34,295
그런 다음에는 이 부분인 랜덤 포레스트 분류자를 실행하고자 합니다.

81

00:04:34,295  -->  00:04:37,560
랜덤 포레스트 분류자는 x와 y를 취합니다.

82

00:04:37,560  -->  00:04:40,375
x PCA와 y가 되겠군요.

83

00:04:40,375  -->  00:04:44,589
이는 정확도를 반환합니다.

84

00:04:44,589  -->  00:04:47,524
바로 여기 이 부분이 출력으로 반환되기에

85

00:04:47,524  -->  00:04:51,054
정확도를 반환한다는 것을 알 수 있는 것이죠.

86

00:04:51,055  -->  00:04:56,209
저는 ACCS라는 빈 목록을 만들려고 합니다.

87

00:04:56,209  -->  00:05:03,944
그런 다음 각 모델의 정확도를 목록에 추가하려고 하죠.

88

00:05:03,944  -->  00:05:13,099
그런 다음 해당 루프 외부에 num 기능을 목록으로 생성할 예정입니다. 좋군요.

89

00:05:13,100  -->  00:05:15,340
이제 이런 것들을 잔뜩 생성할 것입니다.

90

00:05:15,339  -->  00:05:18,379
이것이 세 가지 기능에서 일어나는 일이며,

91

00:05:18,379  -->  00:05:21,384
정확도는 54% 정도입니다.

92

00:05:21,384  -->  00:05:25,925
그런 다음 4개의 기능으로 약 67%의 정확도를 획득합니다.

93

00:05:25,925  -->  00:05:30,235
그런 다음 5개 기능으로는 72%를 달성하고

94

00:05:30,235  -->  00:05:36,030
8개 기능으로는 거의 80%에 가까워지죠.

95

00:05:36,029  -->  00:05:38,304
점점 안정되기 시작하는 것을 볼 수 있습니다.

96

00:05:38,305  -->  00:05:40,879
그 다음에는 84, 85, 86을 받으며

97

00:05:40,879  -->  00:05:44,310
실행이 완료된 것처럼 보입니다.

98

00:05:44,310  -->  00:05:49,129
14개 기능으로 거의 88%에 이르렀죠.

99

00:05:49,129  -->  00:05:53,120
이것보다 약간만 더 위로 올라가야 할 것 같습니다.

100

00:05:53,120  -->  00:06:02,160
그래서 전 기능 15개부터 시작해 20개까지 늘려 나가려고 합니다.

101

00:06:02,160  -->  00:06:07,335
15개 기능으로 90을 달성합니다. 아주 가깝죠.

102

00:06:07,334  -->  00:06:10,404
중단보다 구축하는 것이 더 현명했을지도 모릅니다.

103

00:06:10,404  -->  00:06:14,959
이 모델의 정확도를 중단할 때는

104

00:06:14,959  -->  00:06:19,439
이러한 정확도를 저장한 다음 나중에 추가하면 됩니다.

105

00:06:19,439  -->  00:06:24,875
그래서 우리는 이것과 동일하다고 말한 다음

106

00:06:24,875  -->  00:06:32,685
정확도를 추가하고, 정확도가 0.9보다 많아지면 중단합니다.

107

00:06:32,685  -->  00:06:35,360
이것은 그냥 15부터 실행하는 것보다 훨씬 더

108

00:06:35,360  -->  00:06:37,905
현명한 방법이었을 것입니다.

109

00:06:37,904  -->  00:06:40,209
이제 우리는 100까지 할 수 있습니다.

110

00:06:40,209  -->  00:06:42,669
하지만 20부터 시작하는 것이 현명하겠죠.

111

00:06:42,670  -->  00:06:45,080
이 부분은 지금 여기에서 아무 의미가 없습니다.

112

00:06:45,079  -->  00:06:49,539
20에서 정확도는 약 90이고

113

00:06:49,540  -->  00:06:52,435
다시 내려갑니다. 그렇죠.

114

00:06:52,435  -->  00:06:58,459
이제 아래의 셀 삽입을 보면 출력합니다.

115

00:06:58,459  -->  00:07:01,649
CCS를 볼 수 있습니다.

116

00:07:01,649  -->  00:07:03,114
11개가 있죠.

117

00:07:03,115  -->  00:07:05,975
그러므로 우리가 11을 했음을 알 수 있습니다.

118

00:07:05,975  -->  00:07:07,500
그럼 20에서 30까지입니다.

119

00:07:07,500  -->  00:07:12,379
따라서 우리에게는 기본적으로 90%의 정확도보다 더 높은 정확도를 달성하기 충분한

120

00:07:12,379  -->  00:07:17,795
숫자를 이해할 수 있게 해주는 기능이 30개 있었습니다.

121

00:07:17,795  -->  00:07:23,395
예전에 기능이 700개 이상이었으니, 정말 크게 감소했다고 볼 수 있죠.

122

00:07:23,394  -->  00:07:27,894
추가 기능은 실제로 과적합에 기여할 가능성이 있습니다.

123

00:07:27,894  -->  00:07:31,789
데이터세트에 대해 이러한 일이 발생하고 있다는 증거가 있는지 물었습니다.

124

00:07:31,790  -->  00:07:35,314
이 notebook에서 찾을 수 있는 해결책 파일에 있습니다.

125

00:07:35,314  -->  00:07:39,769
꽤 넓은 범위를 살펴보는데,

126

00:07:39,769  -->  00:07:42,964
제안은 100개 미만의 구성 요소만 보는 것입니다.

127

00:07:42,964  -->  00:07:47,204
우리가 할 수 있는 일은 기본적으로 100개의 구성 요소에 대해 이를 실행하는 것입니다.

128

00:07:47,204  -->  00:07:52,284
그런 다음 여러 구성 요소에 대한 정확도를 플롯으로 작성하고, 하락이 시작되는지 아닌지를 확인해야죠.

129

00:07:52,285  -->  00:07:54,055
또는 CFR 모델이 적합한지도요.

130

00:07:54,055  -->  00:07:57,000
하지만 본질적으로 여기에서는 동일한 프로세스처럼 보입니다.
