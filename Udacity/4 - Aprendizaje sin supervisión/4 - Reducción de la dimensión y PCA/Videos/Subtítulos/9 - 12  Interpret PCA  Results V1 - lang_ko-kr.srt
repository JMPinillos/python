1

00:00:00,000  -->  00:00:03,754
PCA 라이브러리가 scikit-learn에서 작동하는 방식을 살펴보았으므로,

2

00:00:03,754  -->  00:00:06,574
손으로 쓴 숫자 데이터세트에 이를 맞추면

3

00:00:06,575  -->  00:00:09,300
PCA가 우리에게 정확히 무엇을 돌려주는지

4

00:00:09,300  -->  00:00:12,554
이렇게 다양한 부분이 의미하는 부분은 무엇인지 자세히 살펴보아야 합니다.

5

00:00:12,554  -->  00:00:15,394
마지막 동영상에서 중단한 부분부터 시작할까요.

6

00:00:15,394  -->  00:00:18,030
여기에서 전 필요한 라이브러리를 읽었으며

7

00:00:18,030  -->  00:00:20,785
이미지 데이터를 레이블과 기능으로 분할했습니다.

8

00:00:20,785  -->  00:00:22,795
실제 이미지의 픽셀이죠.

9

00:00:22,795  -->  00:00:24,804
이제 상위 30을 살펴볼까요.

10

00:00:24,804  -->  00:00:28,054
이제 앞에서 본 do_PCA 함수를 사용하여

11

00:00:28,054  -->  00:00:29,940
PCA 모델을 만들어 봅시다.

12

00:00:29,940  -->  00:00:32,484
X_PCA 구성 요소도 함께요.

13

00:00:32,484  -->  00:00:34,884
PCA 모델을 살펴보면

14

00:00:34,884  -->  00:00:39,589
도트 탭을 눌러 여기에 이용 가능한 모든 항목을 볼 수 있습니다.

15

00:00:39,590  -->  00:00:42,485
제가 일반적으로 주의를 기울이는 몇 가지 요소가 있는데요.

16

00:00:42,484  -->  00:00:46,460
아주 유용한 explained_variance_ratio와

17

00:00:46,460  -->  00:00:48,674
구성 요소의 수,

18

00:00:48,674  -->  00:00:50,334
기능의 수입니다.

19

00:00:50,335  -->  00:00:53,579
PCA 모델을 보고 도트 탭을 넣으면

20

00:00:53,579  -->  00:00:55,983
이용할 수 있는 것들을 여러 가지 볼 수 있습니다.

21

00:00:55,984  -->  00:00:59,545
이중 몇 가지 항목이 우리 모델에 어떻게 작용하는지 살펴보죠.

22

00:00:59,545  -->  00:01:01,325
아래 notebook에서

23

00:01:01,325  -->  00:01:03,710
scree_plot 함수를 볼 수 있습니다.

24

00:01:03,710  -->  00:01:08,500
이 함수는 각 구성 요소가 설명하는 분산의 양을 플롯으로 표시합니다.

25

00:01:08,500  -->  00:01:10,234
어떻게 보이는지 살펴보죠.

26

00:01:10,234  -->  00:01:12,715
15개의 막대가 있으며

27

00:01:12,715  -->  00:01:15,890
각각의 막대는 주요 구성 요소와 연결됩니다.

28

00:01:15,890  -->  00:01:17,219
기억하신다면 여기 위에

29

00:01:17,219  -->  00:01:20,250
15가지 주요 구성 요소가 있었죠.

30

00:01:20,250  -->  00:01:24,109
막대의 높이는 해당 구성 요소가 설명하는

31

00:01:24,109  -->  00:01:27,814
원래 기능 세트의 가변성 양을 뜻합니다.

32

00:01:27,814  -->  00:01:29,483
그러므로 첫 번째 구성 요소는

33

00:01:29,483  -->  00:01:32,598
사용 가능한 가변성의 6%고

34

00:01:32,599  -->  00:01:35,450
모든 데이터는 해당 구성 요소로 설명됩니다.

35

00:01:35,450  -->  00:01:37,325
두 번째 구성 요소는

36

00:01:37,325  -->  00:01:41,645
총 가변성의 4.29%가 해당 구성 요소로 설명되죠.

37

00:01:41,644  -->  00:01:43,424
이런 식으로 이어지는 겁니다.

38

00:01:43,424  -->  00:01:46,819
첫 번째 구성 요소의 15개 막대로

39

00:01:46,819  -->  00:01:49,949
설명되는 가변성의 총량은 약 35%이며

40

00:01:49,950  -->  00:01:51,620
이를 이 선으로 볼 수 있죠.

41

00:01:51,620  -->  00:01:55,490
이러한 주요 구성 요소는 유지하길 원하는 수를 파악하는 데 도움이 될 수 있습니다.

42

00:01:55,489  -->  00:01:59,509
설명드렸던 대로, 원본 데이터의 분산 때문이죠.

43

00:01:59,510  -->  00:02:04,385
이는 비지도 알고리즘에 대한 메트릭을 생성하는 한 가지 방법입니다.

44

00:02:04,385  -->  00:02:07,609
또한 비지도 알고리즘이

45

00:02:07,609  -->  00:02:12,574
데이터에서 발생하는 상황을 예측하는 데 얼마나 효과적인지 이해할 수 있는 방법이기도 하죠.

46

00:02:12,574  -->  00:02:15,169
우리가 살펴봐야 할 또 다른 사항은

47

00:02:15,169  -->  00:02:18,655
이러한 구성 요소와 오리지널과 다시 관련된다는 점입니다.

48

00:02:18,655  -->  00:02:22,925
notebook에 표시되는 다음 함수는 plot_component라고 합니다.

49

00:02:22,925  -->  00:02:25,850
이 함수는 이미지에서

50

00:02:25,849  -->  00:02:28,894
각 구성 요소에 중요한 픽셀을 강조 표시하죠.

51

00:02:28,895  -->  00:02:30,995
따라서 첫 번째 구성 요소를 살펴보면

52

00:02:30,995  -->  00:02:33,500
이 기능을 사용하는 0의 구성 요소입니다.

53

00:02:33,500  -->  00:02:37,544
아마 데이터세트에서 0을 골라내는 거겠죠.

54

00:02:37,544  -->  00:02:39,844
다른 구성 요소를 보면

55

00:02:39,844  -->  00:02:43,864
이것이 이미지에서 다른 패턴을 선택하는 것을 알 수 있습니다.

56

00:02:43,864  -->  00:02:48,400
이미지를 서로 구별할 수 있도록 말이죠.

57

00:02:48,400  -->  00:02:51,650
기본적으로 이 밝은 노란색의 픽셀은

58

00:02:51,650  -->  00:02:55,685
무거운 가중치이며 이 진한 파란색 픽셀은 가벼운 가중치입니다.

59

00:02:55,685  -->  00:02:59,585
해당 픽셀이 이 특정 구성 요소에

60

00:02:59,585  -->  00:03:03,070
어느 정도로 연관이 있는지를 알려주죠. 자, 이제 여러분의 차례입니다.
