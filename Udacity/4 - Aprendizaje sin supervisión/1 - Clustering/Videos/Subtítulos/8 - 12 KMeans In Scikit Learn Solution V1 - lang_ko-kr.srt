1

00:00:00,000  -->  00:00:02,549
따라서 클러스터링에 대한 이전 화면 캐스트에서

2

00:00:02,549  -->  00:00:06,269
데이터세트를 시뮬레이션한 다음 데이터를 kmeans 모델에

3

00:00:06,269  -->  00:00:10,509
맞추고 얼마나 많은 클러스터가 표시되는지 확인하는 방법을 보았습니다.

4

00:00:10,509  -->  00:00:11,844
그런 다음 자신의 차례가 올 때

5

00:00:11,845  -->  00:00:14,545
다른 수의 클러스터로 이것을 시도했습니다.

6

00:00:14,544  -->  00:00:20,934
따라서 4개가 아닌 2개의 클러스터가 있는 모델을 생성하고

7

00:00:20,934  -->  00:00:25,259
이를 데이터세트에 맞추고 최종적으로

8

00:00:25,260  -->  00:00:29,350
데이터가 어떻게 보이는지 확인하기 위해 데이터세트에서 예측했을 수 있습니다.

9

00:00:29,350  -->  00:00:32,750
두 개의 클러스터가 있는 경우 이것이 그룹화되는 것을 볼 수 있습니다.

10

00:00:32,750  -->  00:00:36,125
그런 다음 다시 7로 시도해 볼 수 있습니다.

11

00:00:36,125  -->  00:00:42,140
이 프로세스는 모든 알고리즘에 대해 수행하는 것과 동일한

12

00:00:42,140  -->  00:00:45,439
프로세스이기 때문에 다른 알고리즘으로

13

00:00:45,439  -->  00:00:49,780
확장할 수 있는 방법을 확인하는 데 도움이 되는 방식으로 반복적이기를 바랍니다.

14

00:00:49,780  -->  00:00:52,070
그러면 이것이 7개가 있는 경우의 모습일 것입니다.

15

00:00:52,070  -->  00:00:55,740
따라서 이 플롯에서 색상이 서로 다른 클러스터와 어떻게 연관되어 있는지 확인할 수 있습니다.

16

00:00:55,740  -->  00:00:58,405
그런 다음 마지막으로 kmeans에 맞추면

17

00:00:58,405  -->  00:01:00,814
데이터를 가져오는 점수 방법이 있습니다.

18

00:01:00,814  -->  00:01:04,739
점수는 포인트가 중심에서 얼마나 떨어져 있는지를 나타냅니다.

19

00:01:04,739  -->  00:01:07,990
여기에서는 여러분이 1-10에 대해

20

00:01:07,989  -->  00:01:10,354
그것을 하고 중심의 수를 추적하기를 원합니다.

21

00:01:10,355  -->  00:01:13,325
그래서 이것은 약간의 시간이 걸리지만

22

00:01:13,325  -->  00:01:18,520
1-11은 우리에게 1에서 10까지 줄 것입니다.

23

00:01:18,519  -->  00:01:22,699
그래서, 각각 4개의 중심과 범위는 1-11인데,

24

00:01:22,700  -->  00:01:26,790
왜냐하면 이것은 포괄적이지 않고 이것이기 때문입니다.

25

00:01:26,790  -->  00:01:31,370
우리는 각 모델에 대한 점수를 얻으려 하고 기본적으로 이와 동일한

26

00:01:31,370  -->  00:01:39,550
단계 프로시저를 따를 수 있고 특정 수의 중심에 맞추려고 합니다.

27

00:01:39,549  -->  00:01:42,280
여러분 사실상 레이블을 원하지 않습니다.

28

00:01:42,280  -->  00:01:45,364
우리에게 원하는 것은 점수 방법을 실행하는 것입니다.

29

00:01:45,364  -->  00:01:47,334
저는 이것들을 없앨 것입니다.

30

00:01:47,334  -->  00:01:52,839
우리는 kmeans 모델을 맞춘 다음 데이터에 점수를 매깁니다.

31

00:01:52,840  -->  00:01:55,299
점수 벡터를 만들겠습니다.

32

00:01:55,299  -->  00:01:57,784
저는 이것을 점수라고 부를 것이고

33

00:01:57,784  -->  00:02:01,229
그것은 단지 목록이 될 것입니다.

34

00:02:01,230  -->  00:02:08,868
점수를 매기고 추가할 것인데 여기에 모델 점수를 추가하고 튜플로 할 것입니다.

35

00:02:08,868  -->  00:02:12,479
여기서 저는 중앙과 점수를 추적합니다.

36

00:02:12,479  -->  00:02:16,134
이것은 중심과 모델 점수를 가져와

37

00:02:16,134  -->  00:02:19,254
튜플에 넣은 후 해당 목록에 첨부해야 합니다.

38

00:02:19,254  -->  00:02:22,754
여기에는 "나만의 scree plot을 만들어 보세요"라고

39

00:02:22,754  -->  00:02:25,104
적을텐데 저는 중심,

40

00:02:25,104  -->  00:02:30,984
같음, 목록, 범위 1-11을 만들 것입니다.

41

00:02:30,985  -->  00:02:34,015
그런 다음 두 개의 목록이 있고 간단한

42

00:02:34,014  -->  00:02:38,239
plt.plot을 수행한 다음 x축에 있는

43

00:02:38,240  -->  00:02:40,670
모든 항목을 수행할 수 있습니다.

44

00:02:40,669  -->  00:02:45,768
우리의 경우에는 중심이고 점수가 되어야 하는 y축에 있는 항목은 무엇이든 됩니다.

45

00:02:45,769  -->  00:02:50,814
제 생각엔 그렇게 될 것입니다. 우리는 plt를 원합니다.

46

00:02:50,814  -->  00:02:56,884
여기에 제목을 붙이고 scree plot이라고 부를 수 있고

47

00:02:56,884  -->  00:03:05,899
plt.x 레이블은 센터 수이고 plt.y 레이블은

48

00:03:06,419  -->  00:03:14,324
점수 또는 중심으로부터의 평균 거리입니다.

49

00:03:14,324  -->  00:03:17,849
이것이 나뉘는지 보겠습니다. 되는군요.

50

00:03:17,849  -->  00:03:21,025
그것은 R 구문과 같습니다. 쉼표입니다.

51

00:03:21,025  -->  00:03:24,230
실제로는 절대값과 같아야 합니다.

52

00:03:24,229  -->  00:03:28,569
Python은 이상한 일을 합니다. 보시죠.

53

00:03:28,569  -->  00:03:31,729
그래서 Python은 모든 점수를 원하는 곳에서 이상한 일을 합니다.

54

00:03:31,729  -->  00:03:34,949
점수가 낮을수록 더 나빠집니다.

55

00:03:34,949  -->  00:03:36,709
이 경우

56

00:03:36,710  -->  00:03:38,275
절대값을 취하면

57

00:03:38,275  -->  00:03:39,760
이상한 일이 됩니다.

58

00:03:39,759  -->  00:03:42,219
그러나 이 절대값은 실제 거리입니다.

59

00:03:42,219  -->  00:03:44,830
이전에는 음수와 같았는데 그것은

60

00:03:44,830  -->  00:03:48,180
scikit-learn이 점수를 매기는 방식 때문입니다.

61

00:03:48,180  -->  00:03:49,680
이것을 토대로

62

00:03:49,680  -->  00:03:53,920
여기 아래쪽이 실제로 평평해지는 곳인 엘보우라는 것을 알 수 있습니다.

63

00:03:53,919  -->  00:03:56,649
따라서 4번까지 상당한 하락과

64

00:03:56,650  -->  00:04:00,450
평균 거리가 있고 그 다음에는 상당히 평평해집니다.

65

00:04:00,449  -->  00:04:02,554
이것을 보면

66

00:04:02,555  -->  00:04:05,810
멋지고, 그것들이 거의 똑같아 보인다는 것을 알 수 있습니다.

67

00:04:05,810  -->  00:04:08,819
이 scree plot을 사용하여 몇 개의 클러스터를 제안하시겠습니까?

68

00:04:08,819  -->  00:04:14,099
당연히 이전에 본 것과 동일한 숫자를 제안할 것입니다.

69

00:04:14,099  -->  00:04:16,860
맞습니다. 데이터가 4개의 클러스터라는 것을 알 수 있습니다.

70

00:04:16,860  -->  00:04:18,495
매우 만족스럽습니다.

71

00:04:18,495  -->  00:04:21,204
4개의 클러스터 다음에 강력한 평준화를 볼 수 있습니다.

72

00:04:21,204  -->  00:04:24,805
이것은 답을 작성하는 셀일 뿐입니다.

73

00:04:24,805  -->  00:04:29,129
저는 4를 추천합니다. 좋습니다.
